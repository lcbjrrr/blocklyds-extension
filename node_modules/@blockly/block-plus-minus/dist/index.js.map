{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/block-plus-minus/webpack/universalModuleDefinition","webpack://@blockly/block-plus-minus/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/block-plus-minus/webpack/bootstrap","webpack://@blockly/block-plus-minus/./src/serialization_helper.js","webpack://@blockly/block-plus-minus/./src/field_minus.js","webpack://@blockly/block-plus-minus/./src/field_plus.js","webpack://@blockly/block-plus-minus/./src/if.js","webpack://@blockly/block-plus-minus/./src/list_create.js","webpack://@blockly/block-plus-minus/./src/procedures.js","webpack://@blockly/block-plus-minus/./src/text_join.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Returns the extra state of the given block (either as XML or a JSO, depending\n * on the block's definition).\n * @param {!Blockly.BlockSvg} block The block to get the extra state of.\n * @returns {string} A stringified version of the extra state of the given\n *     block.\n */\nexport function getExtraBlockState(block) {\n  // TODO: This is a dupe of the BlockChange.getExtraBlockState code, do we\n  //    want to make that public?\n  if (block.saveExtraState) {\n    const state = block.saveExtraState();\n    return state ? JSON.stringify(state) : '';\n  } else if (block.mutationToDom) {\n    const state = block.mutationToDom();\n    return state ? Blockly.Xml.domToText(state) : '';\n  }\n  return '';\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A function that creates a minus button used for mutation.\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\nimport {getExtraBlockState} from './serialization_helper';\n\n/**\n * Creates a minus image field used for mutation.\n * @param {Object=} args Untyped args passed to block.minus when the field\n *     is clicked.\n * @returns {Blockly.FieldImage} The minus field.\n */\nexport function createMinusField(args = undefined) {\n  const minus = new Blockly.FieldImage(minusImage, 15, 15, undefined, onClick_);\n  /**\n   * Untyped args passed to block.minus when the field is clicked.\n   * @type {?(Object|undefined)}\n   * @private\n   */\n  minus.args_ = args;\n  return minus;\n}\n\n/**\n * Calls block.minus(args) when the minus field is clicked.\n * @param {Blockly.FieldImage} minusField The field being clicked.\n * @private\n */\nfunction onClick_(minusField) {\n  // TODO: This is a dupe of the mutator code, anyway to unify?\n  const block = minusField.getSourceBlock();\n\n  if (block.isInFlyout) {\n    return;\n  }\n\n  Blockly.Events.setGroup(true);\n  const oldExtraState = getExtraBlockState(block);\n  block.minus(minusField.args_);\n  const newExtraState = getExtraBlockState(block);\n\n  if (oldExtraState != newExtraState) {\n    Blockly.Events.fire(\n      new Blockly.Events.BlockChange(\n        block,\n        'mutation',\n        null,\n        oldExtraState,\n        newExtraState,\n      ),\n    );\n  }\n  Blockly.Events.setGroup(false);\n}\n\nconst minusImage =\n  'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAw' +\n  'MC9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPS' +\n  'JNMTggMTFoLTEyYy0xLjEwNCAwLTIgLjg5Ni0yIDJzLjg5NiAyIDIgMmgxMmMxLjEwNCAw' +\n  'IDItLjg5NiAyLTJzLS44OTYtMi0yLTJ6IiBmaWxsPSJ3aGl0ZSIgLz48L3N2Zz4K';\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A field for a plus button used for mutation.\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\nimport {getExtraBlockState} from './serialization_helper';\n\n/**\n * Creates a plus image field used for mutation.\n * @param {Object=} args Untyped args passed to block.minus when the field\n *     is clicked.\n * @returns {Blockly.FieldImage} The Plus field.\n */\nexport function createPlusField(args = undefined) {\n  const plus = new Blockly.FieldImage(plusImage, 15, 15, undefined, onClick_);\n  /**\n   * Untyped args passed to block.plus when the field is clicked.\n   * @type {?(Object|undefined)}\n   * @private\n   */\n  plus.args_ = args;\n  return plus;\n}\n\n/**\n * Calls block.plus(args) when the plus field is clicked.\n * @param {!Blockly.FieldImage} plusField The field being clicked.\n * @private\n */\nfunction onClick_(plusField) {\n  // TODO: This is a dupe of the mutator code, anyway to unify?\n  const block = plusField.getSourceBlock();\n\n  if (block.isInFlyout) {\n    return;\n  }\n\n  Blockly.Events.setGroup(true);\n  const oldExtraState = getExtraBlockState(block);\n  block.plus(plusField.args_);\n  const newExtraState = getExtraBlockState(block);\n\n  if (oldExtraState != newExtraState) {\n    Blockly.Events.fire(\n      new Blockly.Events.BlockChange(\n        block,\n        'mutation',\n        null,\n        oldExtraState,\n        newExtraState,\n      ),\n    );\n  }\n  Blockly.Events.setGroup(false);\n}\n\nconst plusImage =\n  'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC' +\n  '9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPSJNMT' +\n  'ggMTBoLTR2LTRjMC0xLjEwNC0uODk2LTItMi0ycy0yIC44OTYtMiAybC4wNzEgNGgtNC4wNz' +\n  'FjLTEuMTA0IDAtMiAuODk2LTIgMnMuODk2IDIgMiAybDQuMDcxLS4wNzEtLjA3MSA0LjA3MW' +\n  'MwIDEuMTA0Ljg5NiAyIDIgMnMyLS44OTYgMi0ydi00LjA3MWw0IC4wNzFjMS4xMDQgMCAyLS' +\n  '44OTYgMi0ycy0uODk2LTItMi0yeiIgZmlsbD0id2hpdGUiIC8+PC9zdmc+Cg==';\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the if block to use a +/- mutator UI.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {createMinusField} from './field_minus';\nimport {createPlusField} from './field_plus';\n\nconst controlsIfMutator = {\n  /**\n   * Number of else-if inputs on this block.\n   * @type {number}\n   */\n  elseIfCount_: 0,\n  /**\n   * Whether this block has an else input or not.\n   * @type {boolean}\n   */\n  hasElse_: false,\n\n  /**\n   * Creates XML to represent the number of else-if and else inputs.\n   * @returns {Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    if (!this.elseIfCount_ && !this.hasElse_) {\n      return null;\n    }\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('elseif', this.elseIfCount_);\n    if (this.hasElse_) {\n      // Has to be stored as an int for backwards compat.\n      container.setAttribute('else', 1);\n    }\n    return container;\n  },\n\n  /**\n   * Parses XML to restore the else-if and else inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('elseif'), 10) || 0;\n    this.hasElse_ = !!parseInt(xmlElement.getAttribute('else'), 10) || 0;\n    if (this.hasElse_ && !this.getInput('ELSE')) {\n      this.appendStatementInput('ELSE').appendField(\n        Blockly.Msg['CONTROLS_IF_MSG_ELSE'],\n      );\n    }\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{elseIfCount: (number|undefined),\n   *     haseElse: (boolean|undefined)}} The state of this block, ie the else\n   *     if count and else state.\n   */\n  saveExtraState: function () {\n    if (!this.elseIfCount_ && !this.hasElse_) {\n      return null;\n    }\n    const state = Object.create(null);\n    if (this.elseIfCount_) {\n      state['elseIfCount'] = this.elseIfCount_;\n    }\n    if (this.hasElse_) {\n      state['hasElse'] = true;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the else if count and\n   *     else state.\n   */\n  loadExtraState: function (state) {\n    const targetCount = state['elseIfCount'] || 0;\n    this.hasElse_ = state['hasElse'] || false;\n    if (this.hasElse_ && !this.getInput('ELSE')) {\n      this.appendStatementInput('ELSE').appendField(\n        Blockly.Msg['CONTROLS_IF_MSG_ELSE'],\n      );\n    }\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Adds else-if and do inputs to the block until the block matches the\n   * target else-if count.\n   * @param {number} targetCount The target number of else-if inputs.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function (targetCount) {\n    while (this.elseIfCount_ < targetCount) {\n      this.addElseIf_();\n    }\n    while (this.elseIfCount_ > targetCount) {\n      this.removeElseIf_();\n    }\n  },\n\n  /**\n   * Callback for the plus field. Adds an else-if input to the block.\n   */\n  plus: function () {\n    this.addElseIf_();\n  },\n\n  /**\n   * Callback for the minus field. Triggers \"removing\" the input at the specific\n   * index.\n   * @see removeInput_\n   * @param {number} index The index of the else-if input to \"remove\".\n   * @this {Blockly.Block}\n   */\n  minus: function (index) {\n    if (this.elseIfCount_ == 0) {\n      return;\n    }\n    this.removeElseIf_(index);\n  },\n\n  /**\n   * Adds an else-if and a do input to the bottom of the block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addElseIf_: function () {\n    // Because else-if inputs are 1-indexed we increment first, decrement last.\n    this.elseIfCount_++;\n    this.appendValueInput('IF' + this.elseIfCount_)\n      .setCheck('Boolean')\n      .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSEIF'])\n      .appendField(\n        createMinusField(this.elseIfCount_),\n        'MINUS' + this.elseIfCount_,\n      );\n    this.appendStatementInput('DO' + this.elseIfCount_).appendField(\n      Blockly.Msg['CONTROLS_IF_MSG_THEN'],\n    );\n\n    // Handle if-elseif-else block.\n    if (this.getInput('ELSE')) {\n      this.moveInputBefore('ELSE', /* put at end */ null);\n    }\n  },\n\n  /**\n   * Appears to remove the input at the given index. Actually shifts attached\n   * blocks and then removes the input at the bottom of the block. This is to\n   * make sure the inputs are always IF0, IF1, etc with no gaps.\n   * @param {?number=} index The index of the input to \"remove\", or undefined\n   *     to remove the last input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removeElseIf_: function (index = undefined) {\n    // The strategy for removing a part at an index is to:\n    //  - Kick any blocks connected to the relevant inputs.\n    //  - Move all connect blocks from the other inputs up.\n    //  - Remove the last input.\n    // This makes sure all of our indices are correct.\n\n    if (index !== undefined && index != this.elseIfCount_) {\n      // Each else-if is two inputs on the block:\n      // the else-if input and the do input.\n      const elseIfIndex = index * 2;\n      const inputs = this.inputList;\n      let connection = inputs[elseIfIndex].connection; // If connection.\n      if (connection.isConnected()) {\n        connection.disconnect();\n      }\n      connection = inputs[elseIfIndex + 1].connection; // Do connection.\n      if (connection.isConnected()) {\n        connection.disconnect();\n      }\n      this.bumpNeighbours();\n      for (let i = elseIfIndex + 2, input; (input = this.inputList[i]); i++) {\n        if (input.name == 'ELSE') {\n          break; // Should be last, so break.\n        }\n        const targetConnection = input.connection.targetConnection;\n        if (targetConnection) {\n          this.inputList[i - 2].connection.connect(targetConnection);\n        }\n      }\n    }\n\n    this.removeInput('IF' + this.elseIfCount_);\n    this.removeInput('DO' + this.elseIfCount_);\n    // Because else-if inputs are 1-indexed we increment first, decrement last.\n    this.elseIfCount_--;\n  },\n};\n\n/**\n * Adds the initial plus button to the if block.\n * @this {Blockly.Block}\n */\nconst controlsIfHelper = function () {\n  this.getInput('IF0').insertFieldAt(0, createPlusField(), 'PLUS');\n};\n\nif (Blockly.Extensions.isRegistered('controls_if_mutator')) {\n  Blockly.Extensions.unregister('controls_if_mutator');\n}\nBlockly.Extensions.registerMutator(\n  'controls_if_mutator',\n  controlsIfMutator,\n  controlsIfHelper,\n);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the list_create block to use a +/- mutator UI.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {createPlusField} from './field_plus';\nimport {createMinusField} from './field_minus';\n\n// Delete original block because there's no way to unregister it:\n// https://github.com/google/blockly-samples/issues/768#issuecomment-885663394\ndelete Blockly.Blocks['lists_create_with'];\n\nBlockly.defineBlocksWithJsonArray([\n  {\n    type: 'lists_create_with',\n    message0: '%{BKY_LISTS_CREATE_EMPTY_TITLE} %1',\n    args0: [\n      {\n        type: 'input_dummy',\n        name: 'EMPTY',\n      },\n    ],\n    output: 'Array',\n    style: 'list_blocks',\n    helpUrl: '%{BKY_LISTS_CREATE_WITH_HELPURL}',\n    tooltip: '%{BKY_LISTS_CREATE_WITH_TOOLTIP}',\n    mutator: 'new_list_create_with_mutator',\n  },\n]);\n\nconst listCreateMutator = {\n  /**\n   * Number of item inputs the block has.\n   * @type {number}\n   */\n  itemCount_: 0,\n\n  /**\n   * Creates XML to represent number of text inputs.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n  /**\n   * Parses XML to restore the text inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{itemCount: number}} The state of this block, ie the item count.\n   */\n  saveExtraState: function () {\n    return {\n      itemCount: this.itemCount_,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function (state) {\n    this.updateShape_(state['itemCount']);\n  },\n\n  /**\n   * Adds inputs to the block until it reaches the target number of inputs.\n   * @param {number} targetCount The target number of inputs for the block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function (targetCount) {\n    while (this.itemCount_ < targetCount) {\n      this.addPart_();\n    }\n    while (this.itemCount_ > targetCount) {\n      this.removePart_();\n    }\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the plus image. Adds an input to the end of the block and\n   * updates the state of the minus.\n   */\n  plus: function () {\n    this.addPart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the minus image. Removes an input from the end of the block\n   * and updates the state of the minus.\n   */\n  minus: function () {\n    if (this.itemCount_ == 0) {\n      return;\n    }\n    this.removePart_();\n    this.updateMinus_();\n  },\n\n  // To properly keep track of indices we have to increment before/after adding\n  // the inputs, and decrement the opposite.\n  // Because we want our first input to be ADD0 (not ADD1) we increment after.\n\n  /**\n   * Adds an input to the end of the block. If the block currently has no\n   * inputs it updates the top 'EMPTY' input to receive a block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addPart_: function () {\n    if (this.itemCount_ == 0) {\n      this.removeInput('EMPTY');\n      this.topInput_ = this.appendValueInput('ADD' + this.itemCount_)\n        .appendField(createPlusField(), 'PLUS')\n        .appendField(Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH']);\n    } else {\n      this.appendValueInput('ADD' + this.itemCount_);\n    }\n    this.itemCount_++;\n  },\n\n  /**\n   * Removes an input from the end of the block. If we are removing the last\n   * input this updates the block to have an 'EMPTY' top input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removePart_: function () {\n    this.itemCount_--;\n    this.removeInput('ADD' + this.itemCount_);\n    if (this.itemCount_ == 0) {\n      this.topInput_ = this.appendDummyInput('EMPTY')\n        .appendField(createPlusField(), 'PLUS')\n        .appendField(Blockly.Msg['LISTS_CREATE_EMPTY_TITLE']);\n    }\n  },\n\n  /**\n   * Makes it so the minus is visible iff there is an input available to remove.\n   * @private\n   */\n  updateMinus_: function () {\n    const minusField = this.getField('MINUS');\n    if (!minusField && this.itemCount_ > 0) {\n      this.topInput_.insertFieldAt(1, createMinusField(), 'MINUS');\n    } else if (minusField && this.itemCount_ < 1) {\n      this.topInput_.removeField('MINUS');\n    }\n  },\n};\n\n/**\n * Updates the shape of the block to have 3 inputs if no mutation is provided.\n * @this {Blockly.Block}\n */\nconst listCreateHelper = function () {\n  this.getInput('EMPTY').insertFieldAt(0, createPlusField(), 'PLUS');\n  this.updateShape_(3);\n};\n\nBlockly.Extensions.registerMutator(\n  'new_list_create_with_mutator',\n  listCreateMutator,\n  listCreateHelper,\n);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the procedure blocks to use a +/- mutator UI.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {createMinusField} from './field_minus';\nimport {createPlusField} from './field_plus';\n\nBlockly.Msg['PROCEDURE_VARIABLE'] = 'variable:';\n\n// Delete original blocks because there's no way to unregister them:\n// https://github.com/google/blockly-samples/issues/768#issuecomment-885663394\ndelete Blockly.Blocks['procedures_defnoreturn'];\ndelete Blockly.Blocks['procedures_defreturn'];\n\nBlockly.defineBlocksWithJsonArray([\n  {\n    type: 'procedures_defnoreturn',\n    message0: '%{BKY_PROCEDURES_DEFNORETURN_TITLE} %1 %2',\n    message1: '%{BKY_PROCEDURES_DEFNORETURN_DO} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFNORETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFNORETURN_TOOLTIP}',\n    extensions: [\n      'get_procedure_def_no_return',\n      'procedure_context_menu',\n      'procedure_rename',\n      'procedure_vars',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n  {\n    type: 'procedures_defreturn',\n    message0: '%{BKY_PROCEDURES_DEFRETURN_TITLE} %1 %2',\n    message1: '%{BKY_PROCEDURES_DEFRETURN_DO} %1',\n    message2: '%{BKY_PROCEDURES_DEFRETURN_RETURN} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    args2: [\n      {\n        type: 'input_value',\n        align: 'right',\n        name: 'RETURN',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFRETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFRETURN_TOOLTIP}',\n    extensions: [\n      'get_procedure_def_return',\n      'procedure_context_menu',\n      'procedure_rename',\n      'procedure_vars',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n]);\n\n/**\n * Defines the what are essentially info-getters for the procedures_defnoreturn\n * block.\n * @type {{callType_: string, getProcedureDef: (function(): Array)}}\n */\nconst getDefNoReturn = {\n  /**\n   * Returns info about this block to be used by the Blockly.Procedures.\n   * @returns {Array} An array of info.\n   * @this {Blockly.Block}\n   */\n  getProcedureDef: function () {\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    return [this.getFieldValue('NAME'), argNames, false];\n  },\n\n  /**\n   * Used by the context menu to create a caller block.\n   * @type {string}\n   */\n  callType_: 'procedures_callnoreturn',\n};\n\nBlockly.Extensions.registerMixin('get_procedure_def_no_return', getDefNoReturn);\n\n/**\n * Defines what are essentially info-getters for the procedures_def_return\n * block.\n * @type {{callType_: string, getProcedureDef: (function(): Array)}}\n */\nconst getDefReturn = {\n  /**\n   * Returns info about this block to be used by the Blockly.Procedures.\n   * @returns {Array} An array of info.\n   * @this {Blockly.Block}\n   */\n  getProcedureDef: function () {\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    return [this.getFieldValue('NAME'), argNames, true];\n  },\n  /**\n   * Used by the context menu to create a caller block.\n   * @type {string}\n   */\n  callType_: 'procedures_callreturn',\n};\n\nBlockly.Extensions.registerMixin('get_procedure_def_return', getDefReturn);\n\nconst procedureContextMenu = {\n  /**\n   * Adds an option to create a caller block.\n   * Adds an option to create a variable getter for each variable included in\n   * the procedure definition.\n   * @this {Blockly.Block}\n   * @param {!Array} options The current options for the context menu.\n   */\n  customContextMenu: function (options) {\n    if (this.isInFlyout) {\n      return;\n    }\n\n    // Add option to create caller.\n    const name = this.getFieldValue('NAME');\n    const text = Blockly.Msg['PROCEDURES_CREATE_DO'].replace('%1', name);\n\n    const xml = Blockly.utils.xml.createElement('block');\n    xml.setAttribute('type', this.callType_);\n    xml.appendChild(this.mutationToDom(true));\n    const callback = Blockly.ContextMenu.callbackFactory(this, xml);\n\n    options.push({\n      enabled: true,\n      text: text,\n      callback: callback,\n    });\n\n    if (this.isCollapsed()) {\n      return;\n    }\n\n    // Add options to create getters for each parameter.\n    const varModels = this.getVarModels();\n    for (const model of varModels) {\n      const text = Blockly.Msg['VARIABLES_SET_CREATE_GET'].replace(\n        '%1',\n        model.name,\n      );\n\n      const xml = Blockly.utils.xml.createElement('block');\n      xml.setAttribute('type', 'variables_get');\n      xml.appendChild(Blockly.Variables.generateVariableFieldDom(model));\n      const callback = Blockly.ContextMenu.callbackFactory(this, xml);\n\n      options.push({\n        enabled: true,\n        text: text,\n        callback: callback,\n      });\n    }\n  },\n};\n\nBlockly.Extensions.registerMixin(\n  'procedure_context_menu',\n  procedureContextMenu,\n);\n\nconst procedureDefMutator = {\n  /**\n   * Create XML to represent the argument inputs.\n   * @param {boolean=} isForCaller If true include the procedure name and\n   *     argument IDs. Used by Blockly.Procedures.mutateCallers for\n   *     reconnection.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function (isForCaller = false) {\n    const container = Blockly.utils.xml.createElement('mutation');\n    if (isForCaller) {\n      container.setAttribute('name', this.getFieldValue('NAME'));\n    }\n    this.argData_.forEach((element) => {\n      const argument = Blockly.utils.xml.createElement('arg');\n      const argModel = element.model;\n      argument.setAttribute('name', argModel.name);\n      argument.setAttribute('varid', argModel.getId());\n      argument.setAttribute('argid', element.argId);\n      if (isForCaller) {\n        argument.setAttribute('paramid', element.argId);\n      }\n      container.appendChild(argument);\n    });\n\n    // Not used by this block, but necessary if switching back and forth\n    // between this mutator UI and the default UI.\n    if (!this.hasStatements_) {\n      container.setAttribute('statements', 'false');\n    }\n\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the argument inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    // We have to handle this so that the user doesn't add blocks to the stack,\n    // in which case it would be impossible to return to the old mutators.\n    this.hasStatements_ = xmlElement.getAttribute('statements') !== 'false';\n    if (!this.hasStatements_) {\n      this.removeInput('STACK');\n    }\n\n    const names = [];\n    const varIds = [];\n    const argIds = [];\n    for (const childNode of xmlElement.childNodes) {\n      if (childNode.nodeName.toLowerCase() == 'arg') {\n        names.push(childNode.getAttribute('name'));\n        varIds.push(\n          childNode.getAttribute('varid') || childNode.getAttribute('varId'),\n        );\n        argIds.push(childNode.getAttribute('argid'));\n      }\n    }\n    this.updateShape_(names, varIds, argIds);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{params: (!Array<{name: string, id: string}>|undefined),\n   *     hasStatements: (boolean|undefined)}} The state of this block, eg the\n   *     parameters and statements.\n   */\n  saveExtraState: function () {\n    if (!this.argData_.length && this.hasStatements_) {\n      return null;\n    }\n\n    const state = Object.create(null);\n    if (this.argData_.length) {\n      state['params'] = [];\n      this.argData_.forEach((arg) => {\n        const model = arg.model;\n        state['params'].push({\n          name: model.name,\n          id: model.getId(),\n          argId: arg.argId,\n        });\n      });\n    }\n    if (!this.hasStatements_) {\n      state['hasStatements'] = false;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, eg the parameters and\n   *     statements.\n   */\n  loadExtraState: function (state) {\n    // We have to handle this so that the user doesn't add blocks to the stack,\n    // in which case it would be impossible to return to the old mutators.\n    this.hasStatements_ = state['hasStatements'] !== false;\n    if (!this.hasStatements_) {\n      this.removeInput('STACK');\n    }\n\n    const names = [];\n    const varIds = [];\n    const argIds = [];\n    if (state['params']) {\n      for (let i = 0; i < state['params'].length; i++) {\n        const param = state['params'][i];\n        names.push(param['name']);\n        varIds.push(param['id']);\n        argIds.push(param['argId']);\n      }\n    }\n    this.updateShape_(names, varIds, argIds);\n  },\n\n  /**\n   * Adds arguments to the block until it matches the targets.\n   * @param {!Array<string>} names An array of argument names to display.\n   * @param {!Array<string>} varIds An array of variable IDs associated with\n   *     those names.\n   * @param {!Array<?string>} argIds An array of argument IDs associated with\n   *     those names.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function (names, varIds, argIds) {\n    if (names.length != varIds.length) {\n      throw Error('names and varIds must have the same length.');\n    }\n    // Usually it's more efficient to modify the block, rather than tearing it\n    // down and rebuilding (less render calls), but in this case it's easier\n    // to just work from scratch.\n\n    // We need to remove args in reverse order so that it doesn't mess up\n    // as removeArg_ modifies our array.\n    for (let i = this.argData_.length - 1; i >= 0; i--) {\n      this.removeArg_(this.argData_[i].argId);\n    }\n    this.argData_ = [];\n    const length = varIds.length;\n    for (let i = 0; i < length; i++) {\n      this.addArg_(names[i], varIds[i], argIds[i]);\n    }\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Callback for the plus image. Adds an argument to the block and mutates\n   * callers to match.\n   */\n  plus: function () {\n    this.addArg_();\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Callback for the minus image. Removes the argument associated with the\n   * given argument ID and mutates the callers to match.\n   * @param {string} argId The argId of the argument to remove.\n   * @this {Blockly.Block}\n   */\n  minus: function (argId) {\n    if (!this.argData_.length) {\n      return;\n    }\n    this.removeArg_(argId);\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Adds an argument to the block and updates the block's parallel tracking\n   * arrays as appropriate.\n   * @param {?string=} name An optional name for the argument.\n   * @param {?string=} varId An optional variable ID for the argument.\n   * @param {?string=} argId An optional argument ID for the argument\n   *     (used to identify the argument across variable merges).\n   * @this {Blockly.Block}\n   * @private\n   */\n  addArg_: function (name = null, varId = null, argId = null) {\n    if (!this.argData_.length) {\n      const withField = new Blockly.FieldLabel(\n        Blockly.Msg['PROCEDURES_BEFORE_PARAMS'],\n      );\n      this.getInput('TOP').appendField(withField, 'WITH');\n    }\n\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    name =\n      name ||\n      Blockly.Variables.generateUniqueNameFromOptions(\n        Blockly.Procedures.DEFAULT_ARG,\n        argNames,\n      );\n    const variable = Blockly.Variables.getOrCreateVariablePackage(\n      this.workspace,\n      varId,\n      name,\n      '',\n    );\n    argId = argId || Blockly.utils.idGenerator.genUid();\n\n    this.addVarInput_(name, argId);\n    if (this.getInput('STACK')) {\n      this.moveInputBefore(argId, 'STACK');\n    } else {\n      this.moveInputBefore(argId, 'RETURN');\n    }\n\n    this.argData_.push({\n      model: variable,\n      argId: argId,\n    });\n  },\n\n  /**\n   * Removes the argument associated with the given argument ID from the block.\n   * @param {string} argId An ID used to track arguments on the block.\n   * @private\n   */\n  removeArg_: function (argId) {\n    if (this.removeInput(argId, true)) {\n      if (this.argData_.length == 1) {\n        // Becoming argumentless.\n        this.getInput('TOP').removeField('WITH');\n      }\n      this.argData_ = this.argData_.filter((element) => element.argId != argId);\n    }\n  },\n\n  /**\n   * Appends the actual inputs and fields associated with an argument to the\n   * block.\n   * @param {string} name The name of the argument.\n   * @param {string} argId The UUID of the argument (different from var ID).\n   * @this {Blockly.Block}\n   * @private\n   */\n  addVarInput_: function (name, argId) {\n    const nameField = new Blockly.FieldTextInput(name, this.validator_);\n    nameField.onFinishEditing_ = this.finishEditing_.bind(nameField);\n    nameField.varIdsToDelete_ = [];\n    nameField.preEditVarModel_ = null;\n\n    this.appendDummyInput(argId)\n      .setAlign(Blockly.inputs.Align.RIGHT)\n      .appendField(createMinusField(argId))\n      .appendField(Blockly.Msg['PROCEDURE_VARIABLE']) // Untranslated!\n      .appendField(nameField, argId); // The name of the field is the arg id.\n  },\n\n  /**\n   * Validates text entered into the argument name field.\n   * @param {string} newName The new text entered into the field.\n   * @returns {?string} The field's new value.\n   * @this {Blockly.FieldTextInput}\n   */\n  validator_: function (newName) {\n    const sourceBlock = this.getSourceBlock();\n    const workspace = sourceBlock.workspace;\n    const argData = sourceBlock.argData_;\n    const argDatum = sourceBlock.argData_.find(\n      (element) => element.argId == this.name,\n    );\n    const currId = argDatum.model.getId();\n\n    // Replace all whitespace with normal spaces, then trim.\n    newName = newName.replace(/[\\s\\xa0]+/g, ' ').trim();\n    const caselessName = newName.toLowerCase();\n\n    /**\n     * Returns true if the given argDatum is associated with this field, or has\n     * a different caseless name than the argDatum associated with this field.\n     * @param {{model: Blockly.VariableModel, argId:string}} argDatum The\n     *     argDatum we want to make sure does not conflict with the argDatum\n     *     associated with this field.\n     * @returns {boolean} True if the given datum does not conflict with the\n     *     datum associated with this field.\n     * @this {Blockly.FieldTextInput}\n     */\n    const hasDifName = (argDatum) => {\n      // The field name (aka id) is always equal to the arg id.\n      return (\n        argDatum.argId == this.name ||\n        caselessName != argDatum.model.name.toLowerCase()\n      );\n    };\n    /**\n     * Returns true if the variable associated with this field is only used\n     * by this block, or callers of this procedure.\n     * @returns {boolean} True if the variable associated with this field is\n     *     only used by this block, or callers of this procedure.\n     */\n    const varOnlyUsedHere = () => {\n      return workspace.getVariableUsesById(currId).every((block) => {\n        return (\n          block.id == sourceBlock.id ||\n          (block.getProcedureCall &&\n            block.getProcedureCall() == sourceBlock.getProcedureDef()[0])\n        );\n      });\n    };\n\n    if (!newName || !argData.every(hasDifName)) {\n      if (this.preEditVarModel_) {\n        argDatum.model = this.preEditVarModel_;\n        this.preEditVarModel_ = null;\n      }\n      Blockly.Procedures.mutateCallers(sourceBlock);\n      return null;\n    }\n\n    if (!this.varIdsToDelete_.length) {\n      this.preEditVarModel_ = argDatum.model;\n      if (varOnlyUsedHere()) {\n        this.varIdsToDelete_.push(currId);\n      }\n    }\n\n    // Create new vars instead of renaming the old ones, so users can't\n    // accidentally rename/coalesce vars.\n    let model = workspace.getVariable(newName, '');\n    if (!model) {\n      model = workspace.createVariable(newName, '');\n      this.varIdsToDelete_.push(model.getId());\n    } else if (model.name != newName) {\n      // Blockly is case-insensitive so we have to update the var instead of\n      // creating a new one.\n      workspace.renameVariableById(model.getId(), newName);\n    }\n    if (model.getId() != currId) {\n      argDatum.model = model;\n    }\n    Blockly.Procedures.mutateCallers(sourceBlock);\n    return newName;\n  },\n\n  /**\n   * Removes any unused vars that were created as a result of editing.\n   * @param {string} _finalName The final value of the field.\n   * @this {Blockly.FieldTextInput}\n   */\n  finishEditing_: function (_finalName) {\n    const source = this.getSourceBlock();\n    const argDatum = source.argData_.find(\n      (element) => element.argId == this.name,\n    );\n\n    const currentVarId = argDatum.model.getId();\n    this.varIdsToDelete_.forEach((id) => {\n      if (id != currentVarId) {\n        source.workspace.deleteVariableById(id);\n      }\n    });\n    this.varIdsToDelete_.length = 0;\n    this.preEditVarModel_ = null;\n  },\n};\n\n/**\n * Initializes some private variables for procedure blocks.\n * @this {Blockly.Block}\n */\nconst procedureDefHelper = function () {\n  /**\n   * An array of objects containing data about the args belonging to the\n   * procedure definition.\n   * @type {!Array<{\n   *          model:Blockly.VariableModel,\n   *          argId: string\n   *       }>}\n   * @private\n   */\n  this.argData_ = [];\n  /**\n   * Does this block have a 'STACK' input for statements?\n   * @type {boolean}\n   * @private\n   */\n  this.hasStatements_ = true;\n\n  this.getInput('TOP').insertFieldAt(0, createPlusField(), 'PLUS');\n};\n\nBlockly.Extensions.registerMutator(\n  'procedure_def_mutator',\n  procedureDefMutator,\n  procedureDefHelper,\n);\n\n/**\n * Sets the validator for the procedure's name field.\n * @this {Blockly.Block}\n */\nconst procedureRename = function () {\n  this.getField('NAME').setValidator(Blockly.Procedures.rename);\n};\n\nBlockly.Extensions.register('procedure_rename', procedureRename);\n\n/**\n * Defines functions for dealing with variables and renaming variables.\n * @this {Blockly.Block}\n */\nconst procedureVars = function () {\n  // This is a hack to get around the don't-override-builtins check.\n  const mixin = {\n    /**\n     * Return all variables referenced by this block.\n     * @returns {!Array.<string>} List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function () {\n      return this.argData_.map((elem) => elem.model.name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     * @returns {!Array.<!Blockly.VariableModel>} List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function () {\n      return this.argData_.map((elem) => elem.model);\n    },\n\n    /**\n     * Notification that a variable was renamed to the same name as an existing\n     * variable. These variables are coalescing into a single variable with the\n     * ID of the variable that was already using the name.\n     * @param {string} oldId The ID of the variable that was renamed.\n     * @param {string} newId The ID of the variable that was already using\n     *     the name.\n     */\n    renameVarById: function (oldId, newId) {\n      const argData = this.argData_.find(\n        (element) => element.model.getId() == oldId,\n      );\n      if (!argData) {\n        return; // Not on this block.\n      }\n\n      const newVar = this.workspace.getVariableById(newId);\n      const newName = newVar.name;\n      this.addVarInput_(newName, newId);\n      this.moveInputBefore(newId, oldId);\n      this.removeInput(oldId);\n      argData.model = newVar;\n      Blockly.Procedures.mutateCallers(this);\n    },\n\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     * @param {!Blockly.VariableModel} variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function (variable) {\n      const id = variable.getId();\n      const argData = this.argData_.find(\n        (element) => element.model.getId() == id,\n      );\n      if (!argData) {\n        return; // Not on this block.\n      }\n      this.setFieldValue(variable.name, argData.argId);\n      argData.model = variable;\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n\nBlockly.Extensions.register('procedure_vars', procedureVars);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the text_join block to use a +/- mutator UI.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {createPlusField} from './field_plus';\nimport {createMinusField} from './field_minus';\n\nconst textJoinMutator = {\n  /**\n   * Number of text inputs on this block.\n   * @type {number}\n   */\n  itemCount_: 0,\n\n  /**\n   * Creates XML to represent number of inputs.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n\n  /**\n   * Parses XML to restore the inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{itemCount: number}} The state of this block, ie the item count.\n   */\n  saveExtraState: function () {\n    return {\n      itemCount: this.itemCount_,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function (state) {\n    this.updateShape_(state['itemCount']);\n  },\n\n  /**\n   * Adds inputs to the block until the block reaches the target input count.\n   * @param {number} targetCount The number of inputs the block should have.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function (targetCount) {\n    while (this.itemCount_ < targetCount) {\n      this.addPart_();\n    }\n    while (this.itemCount_ > targetCount) {\n      this.removePart_();\n    }\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the plus image. Adds an input to the block and updates the\n   * state of the minus.\n   * @this {Blockly.Block}\n   */\n  plus: function () {\n    this.addPart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the minus image. Removes the input at the end of the block and\n   * updates the state of the minus.\n   * @this {Blockly.Block}\n   */\n  minus: function () {\n    if (this.itemCount_ == 0) {\n      return;\n    }\n    this.removePart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Adds an input to the end of the block. If the block currently has no\n   * inputs it updates the top 'EMPTY' input to receive a block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addPart_: function () {\n    if (this.itemCount_ == 0) {\n      if (this.getInput('EMPTY')) {\n        this.removeInput('EMPTY');\n      }\n      this.topInput_ = this.appendValueInput('ADD' + this.itemCount_)\n        .appendField(createPlusField(), 'PLUS')\n        .appendField(Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH']);\n    } else {\n      this.appendValueInput('ADD' + this.itemCount_);\n    }\n    // Because item inputs are 0-index we decrement first, increment last.\n    this.itemCount_++;\n  },\n\n  /**\n   * Removes an input from the end of the block. If we are removing the last\n   * input this updates the block to have an 'EMPTY' top input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removePart_: function () {\n    this.itemCount_--;\n    this.removeInput('ADD' + this.itemCount_);\n    if (this.itemCount_ == 0) {\n      this.topInput_ = this.appendDummyInput('EMPTY')\n        .appendField(createPlusField(), 'PLUS')\n        .appendField(this.newQuote_(true))\n        .appendField(this.newQuote_(false));\n    }\n  },\n\n  /**\n   * Makes it so the minus is visible iff there is an input available to remove.\n   * @private\n   */\n  updateMinus_: function () {\n    const minusField = this.getField('MINUS');\n    if (!minusField && this.itemCount_ > 0) {\n      this.topInput_.insertFieldAt(1, createMinusField(), 'MINUS');\n    } else if (minusField && this.itemCount_ < 1) {\n      this.topInput_.removeField('MINUS');\n    }\n  },\n};\n\n/**\n * Adds the quotes mixin to the block. Also updates the shape so that if no\n * mutator is provided the block has two inputs.\n * @this {Blockly.Block}\n */\nconst textJoinHelper = function () {\n  Blockly.Extensions.apply('quote_image_mixin', this, false);\n  this.updateShape_(2);\n};\n\nif (Blockly.Extensions.isRegistered('text_join_mutator')) {\n  Blockly.Extensions.unregister('text_join_mutator');\n}\nBlockly.Extensions.registerMutator(\n  'text_join_mutator',\n  textJoinMutator,\n  textJoinHelper,\n);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","getExtraBlockState","block","saveExtraState","state","JSON","stringify","mutationToDom","domToText","createMinusField","args","minus","minusImage","onClick_","args_","minusField","getSourceBlock","isInFlyout","setGroup","oldExtraState","newExtraState","fire","BlockChange","createPlusField","plus","plusImage","plusField","controlsIfMutator","elseIfCount_","hasElse_","container","xml","createElement","setAttribute","domToMutation","xmlElement","targetCount","parseInt","getAttribute","getInput","appendStatementInput","appendField","updateShape_","Object","create","loadExtraState","addElseIf_","removeElseIf_","index","appendValueInput","setCheck","moveInputBefore","elseIfIndex","inputs","inputList","connection","isConnected","disconnect","bumpNeighbours","input","name","targetConnection","connect","removeInput","isRegistered","unregister","registerMutator","insertFieldAt","type","message0","args0","output","style","helpUrl","tooltip","mutator","listCreateMutator","itemCount_","itemCount","addPart_","removePart_","updateMinus_","topInput_","appendDummyInput","getField","removeField","message1","text","args1","extensions","message2","args2","align","registerMixin","getProcedureDef","argNames","argData_","map","elem","model","getFieldValue","callType_","procedureContextMenu","customContextMenu","options","replace","appendChild","callback","callbackFactory","push","enabled","isCollapsed","varModels","getVarModels","generateVariableFieldDom","procedureDefMutator","isForCaller","forEach","element","argument","argModel","getId","argId","hasStatements_","names","varIds","argIds","childNode","childNodes","nodeName","toLowerCase","length","arg","id","param","Error","removeArg_","addArg_","mutateCallers","varId","withField","generateUniqueNameFromOptions","DEFAULT_ARG","variable","getOrCreateVariablePackage","workspace","idGenerator","genUid","addVarInput_","filter","nameField","validator_","onFinishEditing_","finishEditing_","bind","varIdsToDelete_","preEditVarModel_","setAlign","Align","RIGHT","newName","sourceBlock","argData","argDatum","find","currId","caselessName","trim","every","getVariableUsesById","getProcedureCall","getVariable","renameVariableById","createVariable","_finalName","source","currentVarId","deleteVariableById","register","setValidator","rename","mixin","getVars","renameVarById","oldId","newId","newVar","getVariableById","updateVarName","setFieldValue","textJoinMutator","newQuote_","apply"],"sourceRoot":""}